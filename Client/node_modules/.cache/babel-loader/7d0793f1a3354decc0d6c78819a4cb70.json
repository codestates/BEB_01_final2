{"ast":null,"code":"'use strict';\n\nconst lt = require('long-timeout');\n\nconst CronDate = require('cron-parser/lib/date');\n\nconst sorted = require('sorted-array-functions');\n\nconst invocations = [];\nlet currentInvocation = null;\n/* DoesntRecur rule */\n\nconst DoesntRecur = new RecurrenceRule();\nDoesntRecur.recurs = false;\n/* Invocation object */\n\nfunction Invocation(job, fireDate, recurrenceRule, endDate) {\n  this.job = job;\n  this.fireDate = fireDate;\n  this.endDate = endDate;\n  this.recurrenceRule = recurrenceRule || DoesntRecur;\n  this.timerID = null;\n}\n\nfunction sorter(a, b) {\n  return a.fireDate.getTime() - b.fireDate.getTime();\n}\n/* Range object */\n\n\nfunction Range(start, end, step) {\n  this.start = start || 0;\n  this.end = end || 60;\n  this.step = step || 1;\n}\n\nRange.prototype.contains = function (val) {\n  if (this.step === null || this.step === 1) {\n    return val >= this.start && val <= this.end;\n  } else {\n    for (let i = this.start; i < this.end; i += this.step) {\n      if (i === val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n/* RecurrenceRule object */\n\n/*\n  Interpreting each property:\n  null - any value is valid\n  number - fixed value\n  Range - value must fall in range\n  array - value must validate against any item in list\n\n  NOTE: Cron months are 1-based, but RecurrenceRule months are 0-based.\n*/\n\n\nfunction RecurrenceRule(year, month, date, dayOfWeek, hour, minute, second) {\n  this.recurs = true;\n  this.year = year == null ? null : year;\n  this.month = month == null ? null : month;\n  this.date = date == null ? null : date;\n  this.dayOfWeek = dayOfWeek == null ? null : dayOfWeek;\n  this.hour = hour == null ? null : hour;\n  this.minute = minute == null ? null : minute;\n  this.second = second == null ? 0 : second;\n}\n\nRecurrenceRule.prototype.isValid = function () {\n  function isValidType(num) {\n    if (Array.isArray(num) || num instanceof Array) {\n      return num.every(function (e) {\n        return isValidType(e);\n      });\n    }\n\n    return !(Number.isNaN(Number(num)) && !(num instanceof Range));\n  }\n\n  if (this.month !== null && (this.month < 0 || this.month > 11 || !isValidType(this.month))) {\n    return false;\n  }\n\n  if (this.dayOfWeek !== null && (this.dayOfWeek < 0 || this.dayOfWeek > 6 || !isValidType(this.dayOfWeek))) {\n    return false;\n  }\n\n  if (this.hour !== null && (this.hour < 0 || this.hour > 23 || !isValidType(this.hour))) {\n    return false;\n  }\n\n  if (this.minute !== null && (this.minute < 0 || this.minute > 59 || !isValidType(this.minute))) {\n    return false;\n  }\n\n  if (this.second !== null && (this.second < 0 || this.second > 59 || !isValidType(this.second))) {\n    return false;\n  }\n\n  if (this.date !== null) {\n    if (!isValidType(this.date)) {\n      return false;\n    }\n\n    switch (this.month) {\n      case 3:\n      case 5:\n      case 8:\n      case 10:\n        if (this.date < 1 || this.date > 30) {\n          return false;\n        }\n\n        break;\n\n      case 1:\n        if (this.date < 1 || this.date > 29) {\n          return false;\n        }\n\n        break;\n\n      default:\n        if (this.date < 1 || this.date > 31) {\n          return false;\n        }\n\n    }\n  }\n\n  return true;\n};\n\nRecurrenceRule.prototype.nextInvocationDate = function (base) {\n  const next = this._nextInvocationDate(base);\n\n  return next ? next.toDate() : null;\n};\n\nRecurrenceRule.prototype._nextInvocationDate = function (base) {\n  base = base instanceof CronDate || base instanceof Date ? base : new Date();\n\n  if (!this.recurs) {\n    return null;\n  }\n\n  if (!this.isValid()) {\n    return null;\n  }\n\n  const now = new CronDate(Date.now(), this.tz);\n  let fullYear = now.getFullYear();\n\n  if (this.year !== null && typeof this.year == 'number' && this.year < fullYear) {\n    return null;\n  }\n\n  let next = new CronDate(base.getTime(), this.tz);\n  next.addSecond();\n\n  while (true) {\n    if (this.year !== null) {\n      fullYear = next.getFullYear();\n\n      if (typeof this.year == 'number' && this.year < fullYear) {\n        next = null;\n        break;\n      }\n\n      if (!recurMatch(fullYear, this.year)) {\n        next.addYear();\n        next.setMonth(0);\n        next.setDate(1);\n        next.setHours(0);\n        next.setMinutes(0);\n        next.setSeconds(0);\n        continue;\n      }\n    }\n\n    if (this.month != null && !recurMatch(next.getMonth(), this.month)) {\n      next.addMonth();\n      continue;\n    }\n\n    if (this.date != null && !recurMatch(next.getDate(), this.date)) {\n      next.addDay();\n      continue;\n    }\n\n    if (this.dayOfWeek != null && !recurMatch(next.getDay(), this.dayOfWeek)) {\n      next.addDay();\n      continue;\n    }\n\n    if (this.hour != null && !recurMatch(next.getHours(), this.hour)) {\n      next.addHour();\n      continue;\n    }\n\n    if (this.minute != null && !recurMatch(next.getMinutes(), this.minute)) {\n      next.addMinute();\n      continue;\n    }\n\n    if (this.second != null && !recurMatch(next.getSeconds(), this.second)) {\n      next.addSecond();\n      continue;\n    }\n\n    break;\n  }\n\n  return next;\n};\n\nfunction recurMatch(val, matcher) {\n  if (matcher == null) {\n    return true;\n  }\n\n  if (typeof matcher === 'number') {\n    return val === matcher;\n  } else if (typeof matcher === 'string') {\n    return val === Number(matcher);\n  } else if (matcher instanceof Range) {\n    return matcher.contains(val);\n  } else if (Array.isArray(matcher) || matcher instanceof Array) {\n    for (let i = 0; i < matcher.length; i++) {\n      if (recurMatch(val, matcher[i])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/* Date-based scheduler */\n\n\nfunction runOnDate(date, job) {\n  const now = Date.now();\n  const then = date.getTime();\n  return lt.setTimeout(function () {\n    if (then > Date.now()) runOnDate(date, job);else job();\n  }, then < now ? 0 : then - now);\n}\n\nfunction scheduleInvocation(invocation) {\n  sorted.add(invocations, invocation, sorter);\n  prepareNextInvocation();\n  const date = invocation.fireDate instanceof CronDate ? invocation.fireDate.toDate() : invocation.fireDate;\n  invocation.job.emit('scheduled', date);\n}\n\nfunction prepareNextInvocation() {\n  if (invocations.length > 0 && currentInvocation !== invocations[0]) {\n    if (currentInvocation !== null) {\n      lt.clearTimeout(currentInvocation.timerID);\n      currentInvocation.timerID = null;\n      currentInvocation = null;\n    }\n\n    currentInvocation = invocations[0];\n    const job = currentInvocation.job;\n    const cinv = currentInvocation;\n    currentInvocation.timerID = runOnDate(currentInvocation.fireDate, function () {\n      currentInvocationFinished();\n\n      if (job.callback) {\n        job.callback();\n      }\n\n      if (cinv.recurrenceRule.recurs || cinv.recurrenceRule._endDate === null) {\n        const inv = scheduleNextRecurrence(cinv.recurrenceRule, cinv.job, cinv.fireDate, cinv.endDate);\n\n        if (inv !== null) {\n          inv.job.trackInvocation(inv);\n        }\n      }\n\n      job.stopTrackingInvocation(cinv);\n\n      try {\n        const result = job.invoke(cinv.fireDate instanceof CronDate ? cinv.fireDate.toDate() : cinv.fireDate);\n        job.emit('run');\n        job.running += 1;\n\n        if (result instanceof Promise) {\n          result.then(function (value) {\n            job.emit('success', value);\n            job.running -= 1;\n          }).catch(function (err) {\n            job.emit('error', err);\n            job.running -= 1;\n          });\n        } else {\n          job.emit('success', result);\n          job.running -= 1;\n        }\n      } catch (err) {\n        job.emit('error', err);\n        job.running -= 1;\n      }\n\n      if (job.isOneTimeJob) {\n        job.deleteFromSchedule();\n      }\n    });\n  }\n}\n\nfunction currentInvocationFinished() {\n  invocations.shift();\n  currentInvocation = null;\n  prepareNextInvocation();\n}\n\nfunction cancelInvocation(invocation) {\n  const idx = invocations.indexOf(invocation);\n\n  if (idx > -1) {\n    invocations.splice(idx, 1);\n\n    if (invocation.timerID !== null) {\n      lt.clearTimeout(invocation.timerID);\n    }\n\n    if (currentInvocation === invocation) {\n      currentInvocation = null;\n    }\n\n    invocation.job.emit('canceled', invocation.fireDate);\n    prepareNextInvocation();\n  }\n}\n/* Recurrence scheduler */\n\n\nfunction scheduleNextRecurrence(rule, job, prevDate, endDate) {\n  prevDate = prevDate instanceof CronDate ? prevDate : new CronDate();\n  const date = rule instanceof RecurrenceRule ? rule._nextInvocationDate(prevDate) : rule.next();\n\n  if (date === null) {\n    return null;\n  }\n\n  if (endDate instanceof CronDate && date.getTime() > endDate.getTime()) {\n    return null;\n  }\n\n  const inv = new Invocation(job, date, rule, endDate);\n  scheduleInvocation(inv);\n  return inv;\n}\n\nmodule.exports = {\n  Range,\n  RecurrenceRule,\n  Invocation,\n  cancelInvocation,\n  scheduleInvocation,\n  scheduleNextRecurrence,\n  sorter,\n  _invocations: invocations\n};","map":{"version":3,"sources":["/Users/yuhojin/Desktop/BEB_01_final2-contract/Client/node_modules/node-schedule/lib/Invocation.js"],"names":["lt","require","CronDate","sorted","invocations","currentInvocation","DoesntRecur","RecurrenceRule","recurs","Invocation","job","fireDate","recurrenceRule","endDate","timerID","sorter","a","b","getTime","Range","start","end","step","prototype","contains","val","i","year","month","date","dayOfWeek","hour","minute","second","isValid","isValidType","num","Array","isArray","every","e","Number","isNaN","nextInvocationDate","base","next","_nextInvocationDate","toDate","Date","now","tz","fullYear","getFullYear","addSecond","recurMatch","addYear","setMonth","setDate","setHours","setMinutes","setSeconds","getMonth","addMonth","getDate","addDay","getDay","getHours","addHour","getMinutes","addMinute","getSeconds","matcher","length","runOnDate","then","setTimeout","scheduleInvocation","invocation","add","prepareNextInvocation","emit","clearTimeout","cinv","currentInvocationFinished","callback","_endDate","inv","scheduleNextRecurrence","trackInvocation","stopTrackingInvocation","result","invoke","running","Promise","value","catch","err","isOneTimeJob","deleteFromSchedule","shift","cancelInvocation","idx","indexOf","splice","rule","prevDate","module","exports","_invocations"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,cAAD,CAAlB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,wBAAD,CAAtB;;AAEA,MAAMG,WAAW,GAAG,EAApB;AACA,IAAIC,iBAAiB,GAAG,IAAxB;AAEA;;AACA,MAAMC,WAAW,GAAG,IAAIC,cAAJ,EAApB;AACAD,WAAW,CAACE,MAAZ,GAAqB,KAArB;AAEA;;AACA,SAASC,UAAT,CAAoBC,GAApB,EAAyBC,QAAzB,EAAmCC,cAAnC,EAAmDC,OAAnD,EAA4D;AAC1D,OAAKH,GAAL,GAAWA,GAAX;AACA,OAAKC,QAAL,GAAgBA,QAAhB;AACA,OAAKE,OAAL,GAAeA,OAAf;AACA,OAAKD,cAAL,GAAsBA,cAAc,IAAIN,WAAxC;AAEA,OAAKQ,OAAL,GAAe,IAAf;AACD;;AAED,SAASC,MAAT,CAAgBC,CAAhB,EAAmBC,CAAnB,EAAsB;AACpB,SAAQD,CAAC,CAACL,QAAF,CAAWO,OAAX,KAAuBD,CAAC,CAACN,QAAF,CAAWO,OAAX,EAA/B;AACD;AAED;;;AACA,SAASC,KAAT,CAAeC,KAAf,EAAsBC,GAAtB,EAA2BC,IAA3B,EAAiC;AAC/B,OAAKF,KAAL,GAAaA,KAAK,IAAI,CAAtB;AACA,OAAKC,GAAL,GAAWA,GAAG,IAAI,EAAlB;AACA,OAAKC,IAAL,GAAYA,IAAI,IAAI,CAApB;AACD;;AAEDH,KAAK,CAACI,SAAN,CAAgBC,QAAhB,GAA2B,UAASC,GAAT,EAAc;AACvC,MAAI,KAAKH,IAAL,KAAc,IAAd,IAAsB,KAAKA,IAAL,KAAc,CAAxC,EAA2C;AACzC,WAAQG,GAAG,IAAI,KAAKL,KAAZ,IAAqBK,GAAG,IAAI,KAAKJ,GAAzC;AACD,GAFD,MAEO;AACL,SAAK,IAAIK,CAAC,GAAG,KAAKN,KAAlB,EAAyBM,CAAC,GAAG,KAAKL,GAAlC,EAAuCK,CAAC,IAAI,KAAKJ,IAAjD,EAAuD;AACrD,UAAII,CAAC,KAAKD,GAAV,EAAe;AACb,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;AACF,CAZD;AAcA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASlB,cAAT,CAAwBoB,IAAxB,EAA8BC,KAA9B,EAAqCC,IAArC,EAA2CC,SAA3C,EAAsDC,IAAtD,EAA4DC,MAA5D,EAAoEC,MAApE,EAA4E;AAC1E,OAAKzB,MAAL,GAAc,IAAd;AAEA,OAAKmB,IAAL,GAAaA,IAAI,IAAI,IAAT,GAAiB,IAAjB,GAAwBA,IAApC;AACA,OAAKC,KAAL,GAAcA,KAAK,IAAI,IAAV,GAAkB,IAAlB,GAAyBA,KAAtC;AACA,OAAKC,IAAL,GAAaA,IAAI,IAAI,IAAT,GAAiB,IAAjB,GAAwBA,IAApC;AACA,OAAKC,SAAL,GAAkBA,SAAS,IAAI,IAAd,GAAsB,IAAtB,GAA6BA,SAA9C;AACA,OAAKC,IAAL,GAAaA,IAAI,IAAI,IAAT,GAAiB,IAAjB,GAAwBA,IAApC;AACA,OAAKC,MAAL,GAAeA,MAAM,IAAI,IAAX,GAAmB,IAAnB,GAA0BA,MAAxC;AACA,OAAKC,MAAL,GAAeA,MAAM,IAAI,IAAX,GAAmB,CAAnB,GAAuBA,MAArC;AACD;;AAED1B,cAAc,CAACgB,SAAf,CAAyBW,OAAzB,GAAmC,YAAW;AAC5C,WAASC,WAAT,CAAqBC,GAArB,EAA0B;AACxB,QAAIC,KAAK,CAACC,OAAN,CAAcF,GAAd,KAAuBA,GAAG,YAAYC,KAA1C,EAAkD;AAChD,aAAOD,GAAG,CAACG,KAAJ,CAAU,UAASC,CAAT,EAAY;AAC3B,eAAOL,WAAW,CAACK,CAAD,CAAlB;AACD,OAFM,CAAP;AAGD;;AACD,WAAO,EAAEC,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACL,GAAD,CAAnB,KAA6B,EAAEA,GAAG,YAAYjB,KAAjB,CAA/B,CAAP;AACD;;AACD,MAAI,KAAKS,KAAL,KAAe,IAAf,KAAwB,KAAKA,KAAL,GAAa,CAAb,IAAkB,KAAKA,KAAL,GAAa,EAA/B,IAAqC,CAACO,WAAW,CAAC,KAAKP,KAAN,CAAzE,CAAJ,EAA4F;AAC1F,WAAO,KAAP;AACD;;AACD,MAAI,KAAKE,SAAL,KAAmB,IAAnB,KAA4B,KAAKA,SAAL,GAAiB,CAAjB,IAAsB,KAAKA,SAAL,GAAiB,CAAvC,IAA4C,CAACK,WAAW,CAAC,KAAKL,SAAN,CAApF,CAAJ,EAA2G;AACzG,WAAO,KAAP;AACD;;AACD,MAAI,KAAKC,IAAL,KAAc,IAAd,KAAuB,KAAKA,IAAL,GAAY,CAAZ,IAAiB,KAAKA,IAAL,GAAY,EAA7B,IAAmC,CAACI,WAAW,CAAC,KAAKJ,IAAN,CAAtE,CAAJ,EAAwF;AACtF,WAAO,KAAP;AACD;;AACD,MAAI,KAAKC,MAAL,KAAgB,IAAhB,KAAyB,KAAKA,MAAL,GAAc,CAAd,IAAmB,KAAKA,MAAL,GAAc,EAAjC,IAAuC,CAACG,WAAW,CAAC,KAAKH,MAAN,CAA5E,CAAJ,EAAgG;AAC9F,WAAO,KAAP;AACD;;AACD,MAAI,KAAKC,MAAL,KAAgB,IAAhB,KAAyB,KAAKA,MAAL,GAAc,CAAd,IAAmB,KAAKA,MAAL,GAAc,EAAjC,IAAuC,CAACE,WAAW,CAAC,KAAKF,MAAN,CAA5E,CAAJ,EAAgG;AAC9F,WAAO,KAAP;AACD;;AACD,MAAI,KAAKJ,IAAL,KAAc,IAAlB,EAAwB;AACtB,QAAG,CAACM,WAAW,CAAC,KAAKN,IAAN,CAAf,EAA4B;AAC1B,aAAO,KAAP;AACD;;AACD,YAAQ,KAAKD,KAAb;AACE,WAAK,CAAL;AACA,WAAK,CAAL;AACA,WAAK,CAAL;AACA,WAAK,EAAL;AACE,YAAI,KAAKC,IAAL,GAAY,CAAZ,IAAiB,KAAMA,IAAN,GAAa,EAAlC,EAAsC;AACpC,iBAAO,KAAP;AACD;;AACD;;AACF,WAAK,CAAL;AACE,YAAI,KAAKA,IAAL,GAAY,CAAZ,IAAiB,KAAMA,IAAN,GAAa,EAAlC,EAAsC;AACpC,iBAAO,KAAP;AACD;;AACD;;AACF;AACE,YAAI,KAAKA,IAAL,GAAY,CAAZ,IAAiB,KAAMA,IAAN,GAAa,EAAlC,EAAsC;AACpC,iBAAO,KAAP;AACD;;AAjBL;AAmBD;;AACD,SAAO,IAAP;AACD,CAjDD;;AAmDAtB,cAAc,CAACgB,SAAf,CAAyBoB,kBAAzB,GAA8C,UAASC,IAAT,EAAe;AAC3D,QAAMC,IAAI,GAAG,KAAKC,mBAAL,CAAyBF,IAAzB,CAAb;;AACA,SAAOC,IAAI,GAAGA,IAAI,CAACE,MAAL,EAAH,GAAmB,IAA9B;AACD,CAHD;;AAKAxC,cAAc,CAACgB,SAAf,CAAyBuB,mBAAzB,GAA+C,UAASF,IAAT,EAAe;AAC5DA,EAAAA,IAAI,GAAKA,IAAI,YAAY1C,QAAjB,IAA+B0C,IAAI,YAAYI,IAAhD,GAAyDJ,IAAzD,GAAiE,IAAII,IAAJ,EAAxE;;AACA,MAAI,CAAC,KAAKxC,MAAV,EAAkB;AAChB,WAAO,IAAP;AACD;;AAED,MAAG,CAAC,KAAK0B,OAAL,EAAJ,EAAoB;AAClB,WAAO,IAAP;AACD;;AAED,QAAMe,GAAG,GAAG,IAAI/C,QAAJ,CAAa8C,IAAI,CAACC,GAAL,EAAb,EAAyB,KAAKC,EAA9B,CAAZ;AACA,MAAIC,QAAQ,GAAGF,GAAG,CAACG,WAAJ,EAAf;;AACA,MAAK,KAAKzB,IAAL,KAAc,IAAf,IACD,OAAO,KAAKA,IAAZ,IAAoB,QADnB,IAED,KAAKA,IAAL,GAAYwB,QAFf,EAE0B;AACxB,WAAO,IAAP;AACD;;AAED,MAAIN,IAAI,GAAG,IAAI3C,QAAJ,CAAa0C,IAAI,CAAC1B,OAAL,EAAb,EAA6B,KAAKgC,EAAlC,CAAX;AACAL,EAAAA,IAAI,CAACQ,SAAL;;AAEA,SAAO,IAAP,EAAa;AACX,QAAI,KAAK1B,IAAL,KAAc,IAAlB,EAAwB;AACtBwB,MAAAA,QAAQ,GAAGN,IAAI,CAACO,WAAL,EAAX;;AACA,UAAK,OAAO,KAAKzB,IAAZ,IAAoB,QAArB,IAAmC,KAAKA,IAAL,GAAYwB,QAAnD,EAA8D;AAC5DN,QAAAA,IAAI,GAAG,IAAP;AACA;AACD;;AAED,UAAI,CAACS,UAAU,CAACH,QAAD,EAAW,KAAKxB,IAAhB,CAAf,EAAsC;AACpCkB,QAAAA,IAAI,CAACU,OAAL;AACAV,QAAAA,IAAI,CAACW,QAAL,CAAc,CAAd;AACAX,QAAAA,IAAI,CAACY,OAAL,CAAa,CAAb;AACAZ,QAAAA,IAAI,CAACa,QAAL,CAAc,CAAd;AACAb,QAAAA,IAAI,CAACc,UAAL,CAAgB,CAAhB;AACAd,QAAAA,IAAI,CAACe,UAAL,CAAgB,CAAhB;AACA;AACD;AACF;;AACD,QAAI,KAAKhC,KAAL,IAAc,IAAd,IAAsB,CAAC0B,UAAU,CAACT,IAAI,CAACgB,QAAL,EAAD,EAAkB,KAAKjC,KAAvB,CAArC,EAAoE;AAClEiB,MAAAA,IAAI,CAACiB,QAAL;AACA;AACD;;AACD,QAAI,KAAKjC,IAAL,IAAa,IAAb,IAAqB,CAACyB,UAAU,CAACT,IAAI,CAACkB,OAAL,EAAD,EAAiB,KAAKlC,IAAtB,CAApC,EAAiE;AAC/DgB,MAAAA,IAAI,CAACmB,MAAL;AACA;AACD;;AACD,QAAI,KAAKlC,SAAL,IAAkB,IAAlB,IAA0B,CAACwB,UAAU,CAACT,IAAI,CAACoB,MAAL,EAAD,EAAgB,KAAKnC,SAArB,CAAzC,EAA0E;AACxEe,MAAAA,IAAI,CAACmB,MAAL;AACA;AACD;;AACD,QAAI,KAAKjC,IAAL,IAAa,IAAb,IAAqB,CAACuB,UAAU,CAACT,IAAI,CAACqB,QAAL,EAAD,EAAkB,KAAKnC,IAAvB,CAApC,EAAkE;AAChEc,MAAAA,IAAI,CAACsB,OAAL;AACA;AACD;;AACD,QAAI,KAAKnC,MAAL,IAAe,IAAf,IAAuB,CAACsB,UAAU,CAACT,IAAI,CAACuB,UAAL,EAAD,EAAoB,KAAKpC,MAAzB,CAAtC,EAAwE;AACtEa,MAAAA,IAAI,CAACwB,SAAL;AACA;AACD;;AACD,QAAI,KAAKpC,MAAL,IAAe,IAAf,IAAuB,CAACqB,UAAU,CAACT,IAAI,CAACyB,UAAL,EAAD,EAAoB,KAAKrC,MAAzB,CAAtC,EAAwE;AACtEY,MAAAA,IAAI,CAACQ,SAAL;AACA;AACD;;AAED;AACD;;AAED,SAAOR,IAAP;AACD,CApED;;AAsEA,SAASS,UAAT,CAAoB7B,GAApB,EAAyB8C,OAAzB,EAAkC;AAChC,MAAIA,OAAO,IAAI,IAAf,EAAqB;AACnB,WAAO,IAAP;AACD;;AAED,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,WAAQ9C,GAAG,KAAK8C,OAAhB;AACD,GAFD,MAEO,IAAG,OAAOA,OAAP,KAAmB,QAAtB,EAAgC;AACrC,WAAQ9C,GAAG,KAAKgB,MAAM,CAAC8B,OAAD,CAAtB;AACD,GAFM,MAEA,IAAIA,OAAO,YAAYpD,KAAvB,EAA8B;AACnC,WAAOoD,OAAO,CAAC/C,QAAR,CAAiBC,GAAjB,CAAP;AACD,GAFM,MAEA,IAAIY,KAAK,CAACC,OAAN,CAAciC,OAAd,KAA2BA,OAAO,YAAYlC,KAAlD,EAA0D;AAC/D,SAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6C,OAAO,CAACC,MAA5B,EAAoC9C,CAAC,EAArC,EAAyC;AACvC,UAAI4B,UAAU,CAAC7B,GAAD,EAAM8C,OAAO,CAAC7C,CAAD,CAAb,CAAd,EAAiC;AAC/B,eAAO,IAAP;AACD;AACF;AACF;;AAED,SAAO,KAAP;AACD;AAED;;;AACA,SAAS+C,SAAT,CAAmB5C,IAAnB,EAAyBnB,GAAzB,EAA8B;AAC5B,QAAMuC,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;AACA,QAAMyB,IAAI,GAAG7C,IAAI,CAACX,OAAL,EAAb;AAEA,SAAOlB,EAAE,CAAC2E,UAAH,CAAc,YAAW;AAC9B,QAAID,IAAI,GAAG1B,IAAI,CAACC,GAAL,EAAX,EACEwB,SAAS,CAAC5C,IAAD,EAAOnB,GAAP,CAAT,CADF,KAGEA,GAAG;AACN,GALM,EAKHgE,IAAI,GAAGzB,GAAP,GAAa,CAAb,GAAiByB,IAAI,GAAGzB,GALrB,CAAP;AAMD;;AAED,SAAS2B,kBAAT,CAA4BC,UAA5B,EAAwC;AACtC1E,EAAAA,MAAM,CAAC2E,GAAP,CAAW1E,WAAX,EAAwByE,UAAxB,EAAoC9D,MAApC;AACAgE,EAAAA,qBAAqB;AACrB,QAAMlD,IAAI,GAAGgD,UAAU,CAAClE,QAAX,YAA+BT,QAA/B,GAA0C2E,UAAU,CAAClE,QAAX,CAAoBoC,MAApB,EAA1C,GAAyE8B,UAAU,CAAClE,QAAjG;AACAkE,EAAAA,UAAU,CAACnE,GAAX,CAAesE,IAAf,CAAoB,WAApB,EAAiCnD,IAAjC;AACD;;AAED,SAASkD,qBAAT,GAAiC;AAC/B,MAAI3E,WAAW,CAACoE,MAAZ,GAAqB,CAArB,IAA0BnE,iBAAiB,KAAKD,WAAW,CAAC,CAAD,CAA/D,EAAoE;AAClE,QAAIC,iBAAiB,KAAK,IAA1B,EAAgC;AAC9BL,MAAAA,EAAE,CAACiF,YAAH,CAAgB5E,iBAAiB,CAACS,OAAlC;AACAT,MAAAA,iBAAiB,CAACS,OAAlB,GAA4B,IAA5B;AACAT,MAAAA,iBAAiB,GAAG,IAApB;AACD;;AAEDA,IAAAA,iBAAiB,GAAGD,WAAW,CAAC,CAAD,CAA/B;AAEA,UAAMM,GAAG,GAAGL,iBAAiB,CAACK,GAA9B;AACA,UAAMwE,IAAI,GAAG7E,iBAAb;AACAA,IAAAA,iBAAiB,CAACS,OAAlB,GAA4B2D,SAAS,CAACpE,iBAAiB,CAACM,QAAnB,EAA6B,YAAW;AAC3EwE,MAAAA,yBAAyB;;AAEzB,UAAIzE,GAAG,CAAC0E,QAAR,EAAkB;AAChB1E,QAAAA,GAAG,CAAC0E,QAAJ;AACD;;AAED,UAAIF,IAAI,CAACtE,cAAL,CAAoBJ,MAApB,IAA8B0E,IAAI,CAACtE,cAAL,CAAoByE,QAApB,KAAiC,IAAnE,EAAyE;AACvE,cAAMC,GAAG,GAAGC,sBAAsB,CAACL,IAAI,CAACtE,cAAN,EAAsBsE,IAAI,CAACxE,GAA3B,EAAgCwE,IAAI,CAACvE,QAArC,EAA+CuE,IAAI,CAACrE,OAApD,CAAlC;;AACA,YAAIyE,GAAG,KAAK,IAAZ,EAAkB;AAChBA,UAAAA,GAAG,CAAC5E,GAAJ,CAAQ8E,eAAR,CAAwBF,GAAxB;AACD;AACF;;AAED5E,MAAAA,GAAG,CAAC+E,sBAAJ,CAA2BP,IAA3B;;AAEA,UAAI;AACF,cAAMQ,MAAM,GAAGhF,GAAG,CAACiF,MAAJ,CAAWT,IAAI,CAACvE,QAAL,YAAyBT,QAAzB,GAAoCgF,IAAI,CAACvE,QAAL,CAAcoC,MAAd,EAApC,GAA6DmC,IAAI,CAACvE,QAA7E,CAAf;AACAD,QAAAA,GAAG,CAACsE,IAAJ,CAAS,KAAT;AACAtE,QAAAA,GAAG,CAACkF,OAAJ,IAAe,CAAf;;AAEA,YAAIF,MAAM,YAAYG,OAAtB,EAA+B;AAC7BH,UAAAA,MAAM,CAAChB,IAAP,CAAY,UAAUoB,KAAV,EAAiB;AAC3BpF,YAAAA,GAAG,CAACsE,IAAJ,CAAS,SAAT,EAAoBc,KAApB;AACApF,YAAAA,GAAG,CAACkF,OAAJ,IAAe,CAAf;AACD,WAHD,EAGGG,KAHH,CAGS,UAAUC,GAAV,EAAe;AACtBtF,YAAAA,GAAG,CAACsE,IAAJ,CAAS,OAAT,EAAkBgB,GAAlB;AACAtF,YAAAA,GAAG,CAACkF,OAAJ,IAAe,CAAf;AACD,WAND;AAOD,SARD,MAQO;AACLlF,UAAAA,GAAG,CAACsE,IAAJ,CAAS,SAAT,EAAoBU,MAApB;AACAhF,UAAAA,GAAG,CAACkF,OAAJ,IAAe,CAAf;AACD;AACF,OAjBD,CAiBE,OAAOI,GAAP,EAAY;AACZtF,QAAAA,GAAG,CAACsE,IAAJ,CAAS,OAAT,EAAkBgB,GAAlB;AACAtF,QAAAA,GAAG,CAACkF,OAAJ,IAAe,CAAf;AACD;;AAED,UAAIlF,GAAG,CAACuF,YAAR,EAAsB;AACpBvF,QAAAA,GAAG,CAACwF,kBAAJ;AACD;AACF,KAzCoC,CAArC;AA0CD;AACF;;AAED,SAASf,yBAAT,GAAqC;AACnC/E,EAAAA,WAAW,CAAC+F,KAAZ;AACA9F,EAAAA,iBAAiB,GAAG,IAApB;AACA0E,EAAAA,qBAAqB;AACtB;;AAED,SAASqB,gBAAT,CAA0BvB,UAA1B,EAAsC;AACpC,QAAMwB,GAAG,GAAGjG,WAAW,CAACkG,OAAZ,CAAoBzB,UAApB,CAAZ;;AACA,MAAIwB,GAAG,GAAG,CAAC,CAAX,EAAc;AACZjG,IAAAA,WAAW,CAACmG,MAAZ,CAAmBF,GAAnB,EAAwB,CAAxB;;AACA,QAAIxB,UAAU,CAAC/D,OAAX,KAAuB,IAA3B,EAAiC;AAC/Bd,MAAAA,EAAE,CAACiF,YAAH,CAAgBJ,UAAU,CAAC/D,OAA3B;AACD;;AAED,QAAIT,iBAAiB,KAAKwE,UAA1B,EAAsC;AACpCxE,MAAAA,iBAAiB,GAAG,IAApB;AACD;;AAEDwE,IAAAA,UAAU,CAACnE,GAAX,CAAesE,IAAf,CAAoB,UAApB,EAAgCH,UAAU,CAAClE,QAA3C;AACAoE,IAAAA,qBAAqB;AACtB;AACF;AAED;;;AACA,SAASQ,sBAAT,CAAgCiB,IAAhC,EAAsC9F,GAAtC,EAA2C+F,QAA3C,EAAqD5F,OAArD,EAA8D;AAE5D4F,EAAAA,QAAQ,GAAIA,QAAQ,YAAYvG,QAArB,GAAiCuG,QAAjC,GAA4C,IAAIvG,QAAJ,EAAvD;AAEA,QAAM2B,IAAI,GAAI2E,IAAI,YAAYjG,cAAjB,GAAmCiG,IAAI,CAAC1D,mBAAL,CAAyB2D,QAAzB,CAAnC,GAAwED,IAAI,CAAC3D,IAAL,EAArF;;AACA,MAAIhB,IAAI,KAAK,IAAb,EAAmB;AACjB,WAAO,IAAP;AACD;;AAED,MAAKhB,OAAO,YAAYX,QAApB,IAAiC2B,IAAI,CAACX,OAAL,KAAiBL,OAAO,CAACK,OAAR,EAAtD,EAAyE;AACvE,WAAO,IAAP;AACD;;AAED,QAAMoE,GAAG,GAAG,IAAI7E,UAAJ,CAAeC,GAAf,EAAoBmB,IAApB,EAA0B2E,IAA1B,EAAgC3F,OAAhC,CAAZ;AACA+D,EAAAA,kBAAkB,CAACU,GAAD,CAAlB;AAEA,SAAOA,GAAP;AACD;;AAEDoB,MAAM,CAACC,OAAP,GAAiB;AACfxF,EAAAA,KADe;AAEfZ,EAAAA,cAFe;AAGfE,EAAAA,UAHe;AAIf2F,EAAAA,gBAJe;AAKfxB,EAAAA,kBALe;AAMfW,EAAAA,sBANe;AAOfxE,EAAAA,MAPe;AAQf6F,EAAAA,YAAY,EAAExG;AARC,CAAjB","sourcesContent":["'use strict';\n\nconst lt = require('long-timeout')\nconst CronDate = require('cron-parser/lib/date')\nconst sorted = require('sorted-array-functions')\n\nconst invocations = [];\nlet currentInvocation = null;\n\n/* DoesntRecur rule */\nconst DoesntRecur = new RecurrenceRule();\nDoesntRecur.recurs = false;\n\n/* Invocation object */\nfunction Invocation(job, fireDate, recurrenceRule, endDate) {\n  this.job = job;\n  this.fireDate = fireDate;\n  this.endDate = endDate;\n  this.recurrenceRule = recurrenceRule || DoesntRecur;\n\n  this.timerID = null;\n}\n\nfunction sorter(a, b) {\n  return (a.fireDate.getTime() - b.fireDate.getTime());\n}\n\n/* Range object */\nfunction Range(start, end, step) {\n  this.start = start || 0;\n  this.end = end || 60;\n  this.step = step || 1;\n}\n\nRange.prototype.contains = function(val) {\n  if (this.step === null || this.step === 1) {\n    return (val >= this.start && val <= this.end);\n  } else {\n    for (let i = this.start; i < this.end; i += this.step) {\n      if (i === val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n\n/* RecurrenceRule object */\n/*\n  Interpreting each property:\n  null - any value is valid\n  number - fixed value\n  Range - value must fall in range\n  array - value must validate against any item in list\n\n  NOTE: Cron months are 1-based, but RecurrenceRule months are 0-based.\n*/\nfunction RecurrenceRule(year, month, date, dayOfWeek, hour, minute, second) {\n  this.recurs = true;\n\n  this.year = (year == null) ? null : year;\n  this.month = (month == null) ? null : month;\n  this.date = (date == null) ? null : date;\n  this.dayOfWeek = (dayOfWeek == null) ? null : dayOfWeek;\n  this.hour = (hour == null) ? null : hour;\n  this.minute = (minute == null) ? null : minute;\n  this.second = (second == null) ? 0 : second;\n}\n\nRecurrenceRule.prototype.isValid = function() {\n  function isValidType(num) {\n    if (Array.isArray(num) || (num instanceof Array)) {\n      return num.every(function(e) {\n        return isValidType(e);\n      });\n    }\n    return !(Number.isNaN(Number(num)) && !(num instanceof Range));\n  }\n  if (this.month !== null && (this.month < 0 || this.month > 11 || !isValidType(this.month))) {\n    return false;\n  }\n  if (this.dayOfWeek !== null && (this.dayOfWeek < 0 || this.dayOfWeek > 6 || !isValidType(this.dayOfWeek))) {\n    return false;\n  }\n  if (this.hour !== null && (this.hour < 0 || this.hour > 23 || !isValidType(this.hour))) {\n    return false;\n  }\n  if (this.minute !== null && (this.minute < 0 || this.minute > 59 || !isValidType(this.minute))) {\n    return false;\n  }\n  if (this.second !== null && (this.second < 0 || this.second > 59 || !isValidType(this.second))) {\n    return false;\n  }\n  if (this.date !== null) {\n    if(!isValidType(this.date)) {\n      return false;\n    }\n    switch (this.month) {\n      case 3:\n      case 5:\n      case 8:\n      case 10:\n        if (this.date < 1 || this. date > 30) {\n          return false;\n        }\n        break;\n      case 1:\n        if (this.date < 1 || this. date > 29) {\n          return false;\n        }\n        break;\n      default:\n        if (this.date < 1 || this. date > 31) {\n          return false;\n        }\n    }\n  }\n  return true;\n};\n\nRecurrenceRule.prototype.nextInvocationDate = function(base) {\n  const next = this._nextInvocationDate(base);\n  return next ? next.toDate() : null;\n};\n\nRecurrenceRule.prototype._nextInvocationDate = function(base) {\n  base = ((base instanceof CronDate) || (base instanceof Date)) ? base : (new Date());\n  if (!this.recurs) {\n    return null;\n  }\n\n  if(!this.isValid()) {\n    return null;\n  }\n\n  const now = new CronDate(Date.now(), this.tz);\n  let fullYear = now.getFullYear();\n  if ((this.year !== null) &&\n    (typeof this.year == 'number') &&\n    (this.year < fullYear)) {\n    return null;\n  }\n\n  let next = new CronDate(base.getTime(), this.tz);\n  next.addSecond();\n\n  while (true) {\n    if (this.year !== null) {\n      fullYear = next.getFullYear();\n      if ((typeof this.year == 'number') && (this.year < fullYear)) {\n        next = null;\n        break;\n      }\n\n      if (!recurMatch(fullYear, this.year)) {\n        next.addYear();\n        next.setMonth(0);\n        next.setDate(1);\n        next.setHours(0);\n        next.setMinutes(0);\n        next.setSeconds(0);\n        continue;\n      }\n    }\n    if (this.month != null && !recurMatch(next.getMonth(), this.month)) {\n      next.addMonth();\n      continue;\n    }\n    if (this.date != null && !recurMatch(next.getDate(), this.date)) {\n      next.addDay();\n      continue;\n    }\n    if (this.dayOfWeek != null && !recurMatch(next.getDay(), this.dayOfWeek)) {\n      next.addDay();\n      continue;\n    }\n    if (this.hour != null && !recurMatch(next.getHours(), this.hour)) {\n      next.addHour();\n      continue;\n    }\n    if (this.minute != null && !recurMatch(next.getMinutes(), this.minute)) {\n      next.addMinute();\n      continue;\n    }\n    if (this.second != null && !recurMatch(next.getSeconds(), this.second)) {\n      next.addSecond();\n      continue;\n    }\n\n    break;\n  }\n\n  return next;\n};\n\nfunction recurMatch(val, matcher) {\n  if (matcher == null) {\n    return true;\n  }\n\n  if (typeof matcher === 'number') {\n    return (val === matcher);\n  } else if(typeof matcher === 'string') {\n    return (val === Number(matcher));\n  } else if (matcher instanceof Range) {\n    return matcher.contains(val);\n  } else if (Array.isArray(matcher) || (matcher instanceof Array)) {\n    for (let i = 0; i < matcher.length; i++) {\n      if (recurMatch(val, matcher[i])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/* Date-based scheduler */\nfunction runOnDate(date, job) {\n  const now = Date.now();\n  const then = date.getTime();\n\n  return lt.setTimeout(function() {\n    if (then > Date.now())\n      runOnDate(date, job);\n    else\n      job();\n  }, (then < now ? 0 : then - now));\n}\n\nfunction scheduleInvocation(invocation) {\n  sorted.add(invocations, invocation, sorter);\n  prepareNextInvocation();\n  const date = invocation.fireDate instanceof CronDate ? invocation.fireDate.toDate() : invocation.fireDate;\n  invocation.job.emit('scheduled', date);\n}\n\nfunction prepareNextInvocation() {\n  if (invocations.length > 0 && currentInvocation !== invocations[0]) {\n    if (currentInvocation !== null) {\n      lt.clearTimeout(currentInvocation.timerID);\n      currentInvocation.timerID = null;\n      currentInvocation = null;\n    }\n\n    currentInvocation = invocations[0];\n\n    const job = currentInvocation.job;\n    const cinv = currentInvocation;\n    currentInvocation.timerID = runOnDate(currentInvocation.fireDate, function() {\n      currentInvocationFinished();\n\n      if (job.callback) {\n        job.callback();\n      }\n\n      if (cinv.recurrenceRule.recurs || cinv.recurrenceRule._endDate === null) {\n        const inv = scheduleNextRecurrence(cinv.recurrenceRule, cinv.job, cinv.fireDate, cinv.endDate);\n        if (inv !== null) {\n          inv.job.trackInvocation(inv);\n        }\n      }\n\n      job.stopTrackingInvocation(cinv);\n\n      try {\n        const result = job.invoke(cinv.fireDate instanceof CronDate ? cinv.fireDate.toDate() : cinv.fireDate);\n        job.emit('run');\n        job.running += 1;\n\n        if (result instanceof Promise) {\n          result.then(function (value) {\n            job.emit('success', value);\n            job.running -= 1;\n          }).catch(function (err) {\n            job.emit('error', err);\n            job.running -= 1;\n          });\n        } else {\n          job.emit('success', result);\n          job.running -= 1;\n        }\n      } catch (err) {\n        job.emit('error', err);\n        job.running -= 1;\n      }\n\n      if (job.isOneTimeJob) {\n        job.deleteFromSchedule();\n      }\n    });\n  }\n}\n\nfunction currentInvocationFinished() {\n  invocations.shift();\n  currentInvocation = null;\n  prepareNextInvocation();\n}\n\nfunction cancelInvocation(invocation) {\n  const idx = invocations.indexOf(invocation);\n  if (idx > -1) {\n    invocations.splice(idx, 1);\n    if (invocation.timerID !== null) {\n      lt.clearTimeout(invocation.timerID);\n    }\n\n    if (currentInvocation === invocation) {\n      currentInvocation = null;\n    }\n\n    invocation.job.emit('canceled', invocation.fireDate);\n    prepareNextInvocation();\n  }\n}\n\n/* Recurrence scheduler */\nfunction scheduleNextRecurrence(rule, job, prevDate, endDate) {\n\n  prevDate = (prevDate instanceof CronDate) ? prevDate : new CronDate();\n\n  const date = (rule instanceof RecurrenceRule) ? rule._nextInvocationDate(prevDate) : rule.next();\n  if (date === null) {\n    return null;\n  }\n\n  if ((endDate instanceof CronDate) && date.getTime() > endDate.getTime()) {\n    return null;\n  }\n\n  const inv = new Invocation(job, date, rule, endDate);\n  scheduleInvocation(inv);\n\n  return inv;\n}\n\nmodule.exports = {\n  Range,\n  RecurrenceRule,\n  Invocation,\n  cancelInvocation,\n  scheduleInvocation,\n  scheduleNextRecurrence,\n  sorter,\n  _invocations: invocations\n}\n"]},"metadata":{},"sourceType":"script"}