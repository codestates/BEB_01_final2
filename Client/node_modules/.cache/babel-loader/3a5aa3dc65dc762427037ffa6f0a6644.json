{"ast":null,"code":"'use strict';\n\nconst events = require('events');\n\nconst cronParser = require('cron-parser');\n\nconst CronDate = require('cron-parser/lib/date');\n\nconst sorted = require('sorted-array-functions');\n\nconst {\n  scheduleNextRecurrence,\n  scheduleInvocation,\n  cancelInvocation,\n  RecurrenceRule,\n  sorter,\n  Invocation\n} = require('./Invocation');\n\nconst {\n  isValidDate\n} = require('./utils/dateUtils');\n\nconst scheduledJobs = {};\nlet anonJobCounter = 0;\n\nfunction resolveAnonJobName() {\n  const now = new Date();\n\n  if (anonJobCounter === Number.MAX_SAFE_INTEGER) {\n    anonJobCounter = 0;\n  }\n\n  anonJobCounter++;\n  return `<Anonymous Job ${anonJobCounter} ${now.toISOString()}>`;\n}\n\nfunction Job(name, job, callback) {\n  // setup a private pendingInvocations variable\n  this.pendingInvocations = []; //setup a private number of invocations variable\n\n  let triggeredJobs = 0; // Set scope vars\n\n  const jobName = name && typeof name === 'string' ? name : resolveAnonJobName();\n  this.job = name && typeof name === 'function' ? name : job; // Make sure callback is actually a callback\n\n  if (this.job === name) {\n    // Name wasn't provided and maybe a callback is there\n    this.callback = typeof job === 'function' ? job : false;\n  } else {\n    // Name was provided, and maybe a callback is there\n    this.callback = typeof callback === 'function' ? callback : false;\n  } // task count\n\n\n  this.running = 0; // Check for generator\n\n  if (typeof this.job === 'function' && this.job.prototype && this.job.prototype.next) {\n    this.job = function () {\n      return this.next().value;\n    }.bind(this.job.call(this));\n  } // define properties\n\n\n  Object.defineProperty(this, 'name', {\n    value: jobName,\n    writable: false,\n    enumerable: true\n  }); // method that require private access\n\n  this.trackInvocation = function (invocation) {\n    // add to our invocation list\n    sorted.add(this.pendingInvocations, invocation, sorter);\n    return true;\n  };\n\n  this.stopTrackingInvocation = function (invocation) {\n    const invIdx = this.pendingInvocations.indexOf(invocation);\n\n    if (invIdx > -1) {\n      this.pendingInvocations.splice(invIdx, 1);\n      return true;\n    }\n\n    return false;\n  };\n\n  this.triggeredJobs = function () {\n    return triggeredJobs;\n  };\n\n  this.setTriggeredJobs = function (triggeredJob) {\n    triggeredJobs = triggeredJob;\n  };\n\n  this.deleteFromSchedule = function () {\n    deleteScheduledJob(this.name);\n  };\n\n  this.cancel = function (reschedule) {\n    reschedule = typeof reschedule == 'boolean' ? reschedule : false;\n    let inv, newInv;\n    const newInvs = [];\n\n    for (let j = 0; j < this.pendingInvocations.length; j++) {\n      inv = this.pendingInvocations[j];\n      cancelInvocation(inv);\n\n      if (reschedule && (inv.recurrenceRule.recurs || inv.recurrenceRule.next)) {\n        newInv = scheduleNextRecurrence(inv.recurrenceRule, this, inv.fireDate, inv.endDate);\n\n        if (newInv !== null) {\n          newInvs.push(newInv);\n        }\n      }\n    }\n\n    this.pendingInvocations = [];\n\n    for (let k = 0; k < newInvs.length; k++) {\n      this.trackInvocation(newInvs[k]);\n    } // remove from scheduledJobs if reschedule === false\n\n\n    if (!reschedule) {\n      this.deleteFromSchedule();\n    }\n\n    return true;\n  };\n\n  this.cancelNext = function (reschedule) {\n    reschedule = typeof reschedule == 'boolean' ? reschedule : true;\n\n    if (!this.pendingInvocations.length) {\n      return false;\n    }\n\n    let newInv;\n    const nextInv = this.pendingInvocations.shift();\n    cancelInvocation(nextInv);\n\n    if (reschedule && (nextInv.recurrenceRule.recurs || nextInv.recurrenceRule.next)) {\n      newInv = scheduleNextRecurrence(nextInv.recurrenceRule, this, nextInv.fireDate, nextInv.endDate);\n\n      if (newInv !== null) {\n        this.trackInvocation(newInv);\n      }\n    }\n\n    return true;\n  };\n\n  this.reschedule = function (spec) {\n    let inv;\n    const invocationsToCancel = this.pendingInvocations.slice();\n\n    for (let j = 0; j < invocationsToCancel.length; j++) {\n      inv = invocationsToCancel[j];\n      cancelInvocation(inv);\n    }\n\n    this.pendingInvocations = [];\n\n    if (this.schedule(spec)) {\n      this.setTriggeredJobs(0);\n      return true;\n    } else {\n      this.pendingInvocations = invocationsToCancel;\n      return false;\n    }\n  };\n\n  this.nextInvocation = function () {\n    if (!this.pendingInvocations.length) {\n      return null;\n    }\n\n    return this.pendingInvocations[0].fireDate;\n  };\n}\n\nObject.setPrototypeOf(Job.prototype, events.EventEmitter.prototype);\n\nJob.prototype.invoke = function (fireDate) {\n  this.setTriggeredJobs(this.triggeredJobs() + 1);\n  return this.job(fireDate);\n};\n\nJob.prototype.runOnDate = function (date) {\n  return this.schedule(date);\n};\n\nJob.prototype.schedule = function (spec) {\n  const self = this;\n  let success = false;\n  let inv;\n  let start;\n  let end;\n  let tz; // save passed-in value before 'spec' is replaced\n\n  if (typeof spec === 'object' && 'tz' in spec) {\n    tz = spec.tz;\n  }\n\n  if (typeof spec === 'object' && spec.rule) {\n    start = spec.start || undefined;\n    end = spec.end || undefined;\n    spec = spec.rule;\n\n    if (start) {\n      if (!(start instanceof Date)) {\n        start = new Date(start);\n      }\n\n      start = new CronDate(start, tz);\n\n      if (!isValidDate(start) || start.getTime() < Date.now()) {\n        start = undefined;\n      }\n    }\n\n    if (end && !(end instanceof Date) && !isValidDate(end = new Date(end))) {\n      end = undefined;\n    }\n\n    if (end) {\n      end = new CronDate(end, tz);\n    }\n  }\n\n  try {\n    const res = cronParser.parseExpression(spec, {\n      currentDate: start,\n      tz: tz\n    });\n    inv = scheduleNextRecurrence(res, self, start, end);\n\n    if (inv !== null) {\n      success = self.trackInvocation(inv);\n    }\n  } catch (err) {\n    const type = typeof spec;\n\n    if (type === 'string' || type === 'number') {\n      spec = new Date(spec);\n    }\n\n    if (spec instanceof Date && isValidDate(spec)) {\n      spec = new CronDate(spec);\n      self.isOneTimeJob = true;\n\n      if (spec.getTime() >= Date.now()) {\n        inv = new Invocation(self, spec);\n        scheduleInvocation(inv);\n        success = self.trackInvocation(inv);\n      }\n    } else if (type === 'object') {\n      self.isOneTimeJob = false;\n\n      if (!(spec instanceof RecurrenceRule)) {\n        const r = new RecurrenceRule();\n\n        if ('year' in spec) {\n          r.year = spec.year;\n        }\n\n        if ('month' in spec) {\n          r.month = spec.month;\n        }\n\n        if ('date' in spec) {\n          r.date = spec.date;\n        }\n\n        if ('dayOfWeek' in spec) {\n          r.dayOfWeek = spec.dayOfWeek;\n        }\n\n        if ('hour' in spec) {\n          r.hour = spec.hour;\n        }\n\n        if ('minute' in spec) {\n          r.minute = spec.minute;\n        }\n\n        if ('second' in spec) {\n          r.second = spec.second;\n        }\n\n        spec = r;\n      }\n\n      spec.tz = tz;\n      inv = scheduleNextRecurrence(spec, self, start, end);\n\n      if (inv !== null) {\n        success = self.trackInvocation(inv);\n      }\n    }\n  }\n\n  scheduledJobs[this.name] = this;\n  return success;\n};\n\nfunction deleteScheduledJob(name) {\n  if (name) {\n    delete scheduledJobs[name];\n  }\n}\n\nmodule.exports = {\n  Job,\n  deleteScheduledJob,\n  scheduledJobs\n};","map":{"version":3,"sources":["/Users/yuhojin/Desktop/BEB_01_final2-contract/Client/node_modules/node-schedule/lib/Job.js"],"names":["events","require","cronParser","CronDate","sorted","scheduleNextRecurrence","scheduleInvocation","cancelInvocation","RecurrenceRule","sorter","Invocation","isValidDate","scheduledJobs","anonJobCounter","resolveAnonJobName","now","Date","Number","MAX_SAFE_INTEGER","toISOString","Job","name","job","callback","pendingInvocations","triggeredJobs","jobName","running","prototype","next","value","bind","call","Object","defineProperty","writable","enumerable","trackInvocation","invocation","add","stopTrackingInvocation","invIdx","indexOf","splice","setTriggeredJobs","triggeredJob","deleteFromSchedule","deleteScheduledJob","cancel","reschedule","inv","newInv","newInvs","j","length","recurrenceRule","recurs","fireDate","endDate","push","k","cancelNext","nextInv","shift","spec","invocationsToCancel","slice","schedule","nextInvocation","setPrototypeOf","EventEmitter","invoke","runOnDate","date","self","success","start","end","tz","rule","undefined","getTime","res","parseExpression","currentDate","err","type","isOneTimeJob","r","year","month","dayOfWeek","hour","minute","second","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst events = require('events')\nconst cronParser = require('cron-parser')\nconst CronDate = require('cron-parser/lib/date')\nconst sorted = require('sorted-array-functions')\n\nconst { scheduleNextRecurrence, scheduleInvocation, cancelInvocation, RecurrenceRule, sorter, Invocation } = require('./Invocation')\nconst { isValidDate } = require('./utils/dateUtils')\n\nconst scheduledJobs = {};\n\nlet anonJobCounter = 0;\nfunction resolveAnonJobName() {\n  const now = new Date()\n  if (anonJobCounter === Number.MAX_SAFE_INTEGER) {\n    anonJobCounter = 0\n  }\n  anonJobCounter++\n\n  return `<Anonymous Job ${anonJobCounter} ${now.toISOString()}>`\n}\n\nfunction Job(name, job, callback) {\n  // setup a private pendingInvocations variable\n  this.pendingInvocations = [];\n\n  //setup a private number of invocations variable\n  let triggeredJobs = 0;\n\n  // Set scope vars\n  const jobName = name && typeof name === 'string' ? name : resolveAnonJobName();\n  this.job = name && typeof name === 'function' ? name : job;\n\n  // Make sure callback is actually a callback\n  if (this.job === name) {\n    // Name wasn't provided and maybe a callback is there\n    this.callback = typeof job === 'function' ? job : false;\n  } else {\n    // Name was provided, and maybe a callback is there\n    this.callback = typeof callback === 'function' ? callback : false;\n  }\n\n  // task count\n  this.running = 0;\n\n  // Check for generator\n  if (typeof this.job === 'function' &&\n    this.job.prototype &&\n    this.job.prototype.next) {\n    this.job = function() {\n      return this.next().value;\n    }.bind(this.job.call(this));\n  }\n\n  // define properties\n  Object.defineProperty(this, 'name', {\n    value: jobName,\n    writable: false,\n    enumerable: true\n  });\n\n  // method that require private access\n  this.trackInvocation = function(invocation) {\n    // add to our invocation list\n    sorted.add(this.pendingInvocations, invocation, sorter);\n    return true;\n  };\n  this.stopTrackingInvocation = function(invocation) {\n    const invIdx = this.pendingInvocations.indexOf(invocation);\n    if (invIdx > -1) {\n      this.pendingInvocations.splice(invIdx, 1);\n      return true;\n    }\n\n    return false;\n  };\n  this.triggeredJobs = function() {\n    return triggeredJobs;\n  };\n  this.setTriggeredJobs = function(triggeredJob) {\n    triggeredJobs = triggeredJob;\n  };\n  this.deleteFromSchedule = function() {\n    deleteScheduledJob(this.name)\n  };\n  this.cancel = function(reschedule) {\n    reschedule = (typeof reschedule == 'boolean') ? reschedule : false;\n\n    let inv, newInv;\n    const newInvs = [];\n    for (let j = 0; j < this.pendingInvocations.length; j++) {\n      inv = this.pendingInvocations[j];\n\n      cancelInvocation(inv);\n\n      if (reschedule && (inv.recurrenceRule.recurs || inv.recurrenceRule.next)) {\n        newInv = scheduleNextRecurrence(inv.recurrenceRule, this, inv.fireDate, inv.endDate);\n        if (newInv !== null) {\n          newInvs.push(newInv);\n        }\n      }\n    }\n\n    this.pendingInvocations = [];\n\n    for (let k = 0; k < newInvs.length; k++) {\n      this.trackInvocation(newInvs[k]);\n    }\n\n    // remove from scheduledJobs if reschedule === false\n    if (!reschedule) {\n      this.deleteFromSchedule()\n    }\n\n    return true;\n  };\n  this.cancelNext = function(reschedule) {\n    reschedule = (typeof reschedule == 'boolean') ? reschedule : true;\n\n    if (!this.pendingInvocations.length) {\n      return false;\n    }\n\n    let newInv;\n    const nextInv = this.pendingInvocations.shift();\n\n    cancelInvocation(nextInv);\n\n    if (reschedule && (nextInv.recurrenceRule.recurs || nextInv.recurrenceRule.next)) {\n      newInv = scheduleNextRecurrence(nextInv.recurrenceRule, this, nextInv.fireDate, nextInv.endDate);\n      if (newInv !== null) {\n        this.trackInvocation(newInv);\n      }\n    }\n\n    return true;\n  };\n  this.reschedule = function(spec) {\n    let inv;\n    const invocationsToCancel = this.pendingInvocations.slice();\n\n    for (let j = 0; j < invocationsToCancel.length; j++) {\n      inv = invocationsToCancel[j];\n\n      cancelInvocation(inv);\n    }\n\n    this.pendingInvocations = [];\n\n    if (this.schedule(spec)) {\n      this.setTriggeredJobs(0);\n      return true;\n    } else {\n      this.pendingInvocations = invocationsToCancel;\n      return false;\n    }\n  };\n  this.nextInvocation = function() {\n    if (!this.pendingInvocations.length) {\n      return null;\n    }\n    return this.pendingInvocations[0].fireDate;\n  };\n}\n\nObject.setPrototypeOf(Job.prototype, events.EventEmitter.prototype);\n\nJob.prototype.invoke = function(fireDate) {\n  this.setTriggeredJobs(this.triggeredJobs() + 1);\n  return this.job(fireDate);\n};\n\nJob.prototype.runOnDate = function(date) {\n  return this.schedule(date);\n};\n\nJob.prototype.schedule = function(spec) {\n  const self = this;\n  let success = false;\n  let inv;\n  let start;\n  let end;\n  let tz;\n\n  // save passed-in value before 'spec' is replaced\n  if (typeof spec === 'object' && 'tz' in spec) {\n    tz = spec.tz;\n  }\n\n  if (typeof spec === 'object' && spec.rule) {\n    start = spec.start || undefined;\n    end = spec.end || undefined;\n    spec = spec.rule;\n\n    if (start) {\n      if (!(start instanceof Date)) {\n        start = new Date(start);\n      }\n\n      start = new CronDate(start, tz);\n      if (!isValidDate(start) || start.getTime() < Date.now()) {\n        start = undefined;\n      }\n    }\n\n    if (end && !(end instanceof Date) && !isValidDate(end = new Date(end))) {\n      end = undefined;\n    }\n\n    if (end) {\n      end = new CronDate(end, tz);\n    }\n  }\n\n  try {\n    const res = cronParser.parseExpression(spec, {currentDate: start, tz: tz});\n    inv = scheduleNextRecurrence(res, self, start, end);\n    if (inv !== null) {\n      success = self.trackInvocation(inv);\n    }\n  } catch (err) {\n    const type = typeof spec;\n    if ((type === 'string') || (type === 'number')) {\n      spec = new Date(spec);\n    }\n\n    if ((spec instanceof Date) && (isValidDate(spec))) {\n      spec = new CronDate(spec);\n      self.isOneTimeJob = true;\n      if (spec.getTime() >= Date.now()) {\n        inv = new Invocation(self, spec);\n        scheduleInvocation(inv);\n        success = self.trackInvocation(inv);\n      }\n    } else if (type === 'object') {\n      self.isOneTimeJob = false;\n      if (!(spec instanceof RecurrenceRule)) {\n        const r = new RecurrenceRule();\n        if ('year' in spec) {\n          r.year = spec.year;\n        }\n        if ('month' in spec) {\n          r.month = spec.month;\n        }\n        if ('date' in spec) {\n          r.date = spec.date;\n        }\n        if ('dayOfWeek' in spec) {\n          r.dayOfWeek = spec.dayOfWeek;\n        }\n        if ('hour' in spec) {\n          r.hour = spec.hour;\n        }\n        if ('minute' in spec) {\n          r.minute = spec.minute;\n        }\n        if ('second' in spec) {\n          r.second = spec.second;\n        }\n\n        spec = r;\n      }\n\n      spec.tz = tz;\n      inv = scheduleNextRecurrence(spec, self, start, end);\n      if (inv !== null) {\n        success = self.trackInvocation(inv);\n      }\n    }\n  }\n\n  scheduledJobs[this.name] = this;\n  return success;\n};\n\nfunction deleteScheduledJob(name) {\n  if (name) {\n    delete scheduledJobs[name];\n  }\n}\n\nmodule.exports = {\n  Job,\n  deleteScheduledJob,\n  scheduledJobs\n}\n"]},"metadata":{},"sourceType":"script"}